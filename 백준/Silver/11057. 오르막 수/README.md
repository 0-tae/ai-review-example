# [Silver I] 오르막 수 - 11057 

[문제 링크](https://www.acmicpc.net/problem/11057) 

### 성능 요약

메모리: 14340 KB, 시간: 116 ms

### 분류

다이나믹 프로그래밍

### 제출 일자

2025년 2월 4일 16:06:49

### 문제 설명

<p>오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다. 이때, 인접한 수가 같아도 오름차순으로 친다.</p>

<p>예를 들어, 2234와 3678, 11119는 오르막 수이지만, 2232, 3676, 91111은 오르막 수가 아니다.</p>

<p>수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램을 작성하시오. 수는 0으로 시작할 수 있다.</p>

### 입력 

 <p>첫째 줄에 N (1 ≤ N ≤ 1,000)이 주어진다.</p>

### 출력 

 <p>첫째 줄에 길이가 N인 오르막 수의 개수를 10,007로 나눈 나머지를 출력한다.</p>

### AI 코드 리뷰

<template>

### 코드 리뷰
```java
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N =Integer.parseInt(br.readLine());
        int[][] dp = new int[N+1][10];
        int D=10007;

        for(int i = 1;i<N+1;i++){
            dp[i][0] = 1;
            for(int k = 1;k<10;k++) {
                dp[i][k] = ((dp[i-1][k] % D) + (dp[i][k-1] % D)) % D;
            }
        }

        System.out.println(Arrays.stream(dp[N]).sum() % D);
    }
}
```
이 코드는 오르막 수의 개수를 계산하는 프로그램입니다. 오르막 수는 수의 각 자리수가 오름차순으로 배열된 수를 의미하며, 인접한 수가 같더라도 오름차순으로 간주합니다. 주어진 수의 길이 N에 대해, 0부터 9까지의 숫자를 사용하여 만들 수 있는 오르막 수의 개수를 계산하고, 그 결과를 10007로 나눈 나머지를 출력합니다.

코드 블록 1 -> 
```java
int N =Integer.parseInt(br.readLine());
int[][] dp = new int[N+1][10];
int D=10007;
```
설명 1 -> 이 부분에서는 입력값 N을 읽어들이고, DP 배열 dp를 초기화합니다. dp[i][j]는 길이가 i인 오르막 수 중에서 마지막 자리가 j인 경우의 수를 나타냅니다. D는 나머지 연산에 사용되는 상수입니다.

코드 블록 2 -> 
```java
for(int i = 1;i<N+1;i++){
    dp[i][0] = 1;
    for(int k = 1;k<10;k++) {
        dp[i][k] = ((dp[i-1][k] % D) + (dp[i][k-1] % D)) % D;
    }
}
```
설명 2 -> 이 부분은 동적 프로그래밍을 통해 dp 배열을 채우는 로직입니다. 길이 i인 오르막 수에서 마지막 자리가 0일 경우는 항상 1로 설정하고, 그 외의 경우는 이전 길이의 같은 숫자에서 올 수 있는 경우와 현재 숫자보다 작은 숫자에서 올 수 있는 경우를 합산하여 dp 배열에 저장합니다.

코드 블록 3 -> 
```java
System.out.println(Arrays.stream(dp[N]).sum() % D);
```
설명 3 -> 이 부분에서는 길이가 N인 오르막 수의 모든 경우의 수를 합산한 후, 결과를 10007로 나눈 나머지를 출력합니다.

### 시간/공간 복잡도 분석
- **시간 복잡도**: O(N)입니다. 이중 루프에서 외부 루프는 N번 실행되고, 내부 루프는 10번 실행되므로 전체적으로 O(N * 10) = O(N)입니다.
- **공간 복잡도**: O(N)입니다. dp 배열은 (N+1) x 10 크기를 가지므로 O(N) 공간을 사용합니다. 

### 코드 최적화 가능성 및 개선 제안
- **코드 최적화 가능성**: 현재 코드에서 dp 배열의 크기를 줄일 수 있습니다. 이전 상태만 필요하므로, 1차원 배열을 사용하여 현재 길이에 대한 결과만 저장하고, 이전 결과를 참조하여 계산할 수 있습니다.
- **개선 제안사항**:
    1. 2차원 배열을 1차원 배열로 변경하여 메모리 사용량을 줄일 수 있습니다. 예를 들어, dp[k] 배열을 사용하여 dp[i][0]에서 dp[i][9]까지의 값을 저장할 수 있습니다.
    2. `sum()` 메서드를 사용할 때 전체 배열을 순회하므로, 이를 직접 누적합으로 계산하여 성능을 개선할 수 있습니다.
    3. 코드의 가독성을 높이기 위해 각 단계에 대한 주석을 추가하는 것이 좋습니다.
- **가독성 및 유지보수성**: 현재 코드의 가독성은 양호하나, 변수명이나 주석을 통해 코드의 의도를 더욱 명확히 할 수 있습니다. 예를 들어, `dp`를 `count`로 변경하여 각 자리수의 개수를 저장하고 있음을 명시적으로 표현할 수 있습니다.

</template>

